#!/bin/bash
# Post-merge hook for integrated worktree removal and Docker cleanup
# This hook detects merged branches, removes their worktrees, and cleans up VS Code Dev Container artifacts

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
NC='\033[0m'

# Logging setup
HOOK_LOG=".git/hooks/post-merge.log"

log_message() {
    # Ensure log directory exists
    mkdir -p "$(dirname "$HOOK_LOG")" 2>/dev/null || true
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" >> "$HOOK_LOG"
}

print_status() {
    echo -e "${BLUE}[CLEANUP]${NC} $1"
    log_message "INFO: $1"
}

print_success() {
    echo -e "${GREEN}[CLEANUP]${NC} $1"
    log_message "SUCCESS: $1"
}

print_warning() {
    echo -e "${YELLOW}[CLEANUP]${NC} $1"
    log_message "WARNING: $1"
}

print_error() {
    echo -e "${RED}[CLEANUP]${NC} $1"
    log_message "ERROR: $1"
}

# Function to check if Docker is available
check_docker() {
    if ! command -v docker >/dev/null 2>&1; then
        print_warning "Docker not found, Docker cleanup will be skipped"
        return 1
    fi
    
    if ! docker info >/dev/null 2>&1; then
        print_warning "Docker daemon not accessible, Docker cleanup will be skipped"
        return 1
    fi
    
    return 0
}

# Function to get the branch that was just merged
get_merged_branch() {
    # Get the merge commit message
    local merge_msg
    merge_msg=$(git log -1 --pretty=%B HEAD 2>/dev/null || echo "")
    
    # Parse different merge message formats
    local branch_name=""
    
    # Format: "Merge branch 'feature-branch'"
    if [[ $merge_msg =~ Merge\ branch\ \'([^\']+)\' ]]; then
        branch_name="${BASH_REMATCH[1]}"
    # Format: "Merge pull request #123 from user/feature-branch"
    elif [[ $merge_msg =~ Merge\ pull\ request.*from\ [^/]+/(.+) ]]; then
        branch_name="${BASH_REMATCH[1]}"
    # Format: Custom merge messages that contain branch name
    elif [[ $merge_msg =~ ([a-zA-Z0-9/_-]+) ]]; then
        # This is a fallback - might need refinement
        branch_name="${BASH_REMATCH[1]}"
    fi
    
    echo "$branch_name"
}

# Function to find worktrees using a specific branch
find_worktrees_for_branch() {
    local branch_name="$1"
    local worktrees=()
    
    if [ -z "$branch_name" ]; then
        return 0
    fi
    
    # Parse git worktree list output
    while IFS= read -r line; do
        if [[ $line == worktree* ]]; then
            local current_worktree_path="${line#worktree }"
            # Continue reading to find the branch for this worktree
            continue
        elif [[ $line == branch* ]] && [[ -n "$current_worktree_path" ]]; then
            local worktree_branch="${line#branch refs/heads/}"
            if [[ "$worktree_branch" == "$branch_name" ]]; then
                worktrees+=("$current_worktree_path")
            fi
            current_worktree_path=""
        fi
    done < <(git worktree list --porcelain 2>/dev/null || true)
    
    printf '%s\n' "${worktrees[@]}"
}

# Function to get Docker artifacts for a worktree
get_docker_artifacts() {
    local worktree_name="$1"
    local artifacts_found=false
    
    # Check for containers
    local containers
    containers=$(docker ps -a --filter "name=${worktree_name}_devcontainer" --format "{{.Names}}" 2>/dev/null || true)
    if [ -n "$containers" ]; then
        echo "Containers:"
        echo "$containers" | sed 's/^/  /'
        artifacts_found=true
    fi
    
    # Check for images  
    local images
    images=$(docker images --filter "reference=vsc-${worktree_name}-*" --format "{{.Repository}}:{{.Tag}}" 2>/dev/null || true)
    if [ -n "$images" ]; then
        echo "Images:"
        echo "$images" | sed 's/^/  /'
        artifacts_found=true
    fi
    
    # Check for volumes
    local volumes
    volumes=$(docker volume ls --filter "name=vsc-${worktree_name}" --format "{{.Name}}" 2>/dev/null || true)
    if [ -n "$volumes" ]; then
        echo "Volumes:"
        echo "$volumes" | sed 's/^/  /'
        artifacts_found=true
    fi
    
    # Check for networks
    local networks
    networks=$(docker network ls --filter "name=${worktree_name}_devcontainer" --format "{{.Name}}" 2>/dev/null || true)
    if [ -n "$networks" ]; then
        echo "Networks:"
        echo "$networks" | sed 's/^/  /'
        artifacts_found=true
    fi
    
    $artifacts_found
}

# Function to clean up Docker artifacts
cleanup_docker_artifacts() {
    local worktree_name="$1"
    local cleanup_count=0
    
    print_status "Cleaning up Docker artifacts for worktree: $worktree_name"
    
    # Remove containers
    local containers
    containers=$(docker ps -a --filter "name=${worktree_name}_devcontainer" -q 2>/dev/null || true)
    if [ -n "$containers" ]; then
        echo "$containers" | xargs docker rm -f >/dev/null 2>&1 && {
            local container_count
            container_count=$(echo "$containers" | wc -l)
            print_success "✓ Removed $container_count containers"
            ((cleanup_count += container_count))
        }
    fi
    
    # Remove images
    local images
    images=$(docker images --filter "reference=vsc-${worktree_name}-*" -q 2>/dev/null || true)
    if [ -n "$images" ]; then
        echo "$images" | xargs docker rmi -f >/dev/null 2>&1 && {
            local image_count
            image_count=$(echo "$images" | wc -l)
            print_success "✓ Removed $image_count images"
            ((cleanup_count += image_count))
        }
    fi
    
    # Remove volumes
    local volumes
    volumes=$(docker volume ls --filter "name=vsc-${worktree_name}" -q 2>/dev/null || true)
    if [ -n "$volumes" ]; then
        echo "$volumes" | xargs docker volume rm >/dev/null 2>&1 && {
            local volume_count
            volume_count=$(echo "$volumes" | wc -l)
            print_success "✓ Removed $volume_count volumes"
            ((cleanup_count += volume_count))
        }
    fi
    
    # Remove networks (be careful with default networks)
    local networks
    networks=$(docker network ls --filter "name=${worktree_name}_devcontainer" --format "{{.Name}}" 2>/dev/null | grep -v "^bridge$\|^host$\|^none$" || true)
    if [ -n "$networks" ]; then
        echo "$networks" | xargs docker network rm >/dev/null 2>&1 && {
            local network_count
            network_count=$(echo "$networks" | wc -l)
            print_success "✓ Removed $network_count networks"
            ((cleanup_count += network_count))
        }
    fi
    
    if [ $cleanup_count -gt 0 ]; then
        print_success "Cleaned up $cleanup_count Docker artifacts"
    else
        print_status "No Docker artifacts found to clean up"
    fi
}

# Function to prompt user for confirmation
prompt_user_confirmation() {
    local worktree_path="$1"
    local worktree_name
    worktree_name=$(basename "$worktree_path")
    
    echo ""
    echo -e "${BLUE}🔍 Found worktree for merged branch:${NC}"
    echo "   Path: $worktree_path"
    echo ""
    
    # Check for Docker artifacts
    if check_docker; then
        echo -e "${BLUE}🗑️  Docker artifacts that will be removed:${NC}"
        if get_docker_artifacts "$worktree_name"; then
            echo ""
        else
            echo "   No Docker artifacts found"
            echo ""
        fi
    fi
    
    # Prompt for confirmation
    echo -e "${YELLOW}Remove worktree and associated Docker resources?${NC}"
    read -p "Remove '$worktree_name'? (y/N): " -n 1 -r
    echo ""
    
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        return 0
    else
        return 1
    fi
}

# Main execution
main() {
    log_message "Post-merge hook triggered"
    
    # Check if we're in a git repository
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        print_error "Not in a git repository"
        exit 1
    fi
    
    print_status "Merge completed. Checking for worktrees to clean up..."
    
    # Get the branch that was just merged
    local merged_branch
    merged_branch=$(get_merged_branch)
    
    if [ -z "$merged_branch" ]; then
        print_status "Could not determine merged branch from commit message"
        log_message "No merged branch detected, exiting"
        exit 0
    fi
    
    print_status "Detected merged branch: $merged_branch"
    
    # Find worktrees using this branch
    local worktrees=()
    while IFS= read -r worktree_path; do
        if [ -n "$worktree_path" ]; then
            worktrees+=("$worktree_path")
        fi
    done < <(find_worktrees_for_branch "$merged_branch")
    
    if [ ${#worktrees[@]} -eq 0 ]; then
        print_status "No worktrees found for merged branch '$merged_branch'"
        log_message "No worktrees to clean up"
        exit 0
    fi
    
    # Process each worktree
    for worktree_path in "${worktrees[@]}"; do
        if prompt_user_confirmation "$worktree_path"; then
            local worktree_name
            worktree_name=$(basename "$worktree_path")
            
            print_status "Removing worktree: $worktree_path"
            
            # Remove the worktree
            if git worktree remove "$worktree_path" 2>/dev/null; then
                print_success "✅ Removed worktree: $worktree_name"
                
                # Clean up Docker artifacts if Docker is available
                if check_docker; then
                    cleanup_docker_artifacts "$worktree_name"
                fi
            else
                print_error "Failed to remove worktree: $worktree_path"
                print_warning "Skipping Docker cleanup for failed worktree removal"
            fi
        else
            print_status "Skipped worktree: $(basename "$worktree_path")"
        fi
        echo ""
    done
    
    print_success "Post-merge cleanup completed!"
    log_message "Post-merge hook completed"
}

# Execute only if not being sourced
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi